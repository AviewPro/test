<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Start to Press Any Button - Master Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: url('space_back1.gif') no-repeat center center fixed;
            background-size: cover;
            transition: background 0.5s ease-in-out;
            /* [수정/메모] 모바일 터치 간섭(스크롤, 확대) 방지 */
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const HIDDEN_MESSAGE = "저의 두번째 게임 Start to Press Any Button을 즐겨주셔서 감사합니다";
        
        const sfxBounce = new Audio('띠용.mp3');
        const MAX_BOUNCE_VOL = 0.6;
        const sfxDeath = new Audio('꺼지는소리.mp3');
        
        const bgmAir = new Audio('Air 8-bit.mp3');
        bgmAir.loop = true; bgmAir.volume = 0.1;
        const bgmSym25 = new Audio('Symphony no. 25 8-bit.mp3');
        bgmSym25.loop = true; bgmSym25.volume = 0.3;
        const bgmWinter = new Audio('Winter, The Four Seasons 8-bit.mp3');
        bgmWinter.loop = true; bgmWinter.volume = 0.3;
        const bgmMoonlight = new Audio('Moonlight Sonata 8-bit.mp3');
        bgmMoonlight.loop = true; bgmMoonlight.volume = 0.25;

        const imgAview = new Image();
        imgAview.src = 'Aview.png';

        function updateBGM() {
            if (isStageTransition && isEnding && fadeAlpha >= 1) return;
            if (isEnding || isShowingCredit || isHiddenEnding) {
                if (bgmMoonlight.paused) { stopAllBGM(); bgmMoonlight.play().catch(e => {}); }
            } else if (currentStage >= 7) {
                if (bgmWinter.paused) { stopAllBGM(); bgmWinter.play().catch(e => {}); }
            } else if (currentStage >= 5) {
                if (bgmSym25.paused) { stopAllBGM(); bgmSym25.play().catch(e => {}); }
            } else {
                if (bgmAir.paused) { stopAllBGM(); bgmAir.play().catch(e => {}); }
            }
        }

        function stopAllBGM() {
            [bgmAir, bgmSym25, bgmWinter, bgmMoonlight].forEach(bgm => {
                bgm.pause();
                bgm.currentTime = 0;
            });
        }

        /**
         * [신규/메모] 전체화면 전환 함수
         * 브라우저 보안 정책상 첫 상호작용 시 호출해야 함
         */
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => {
                    console.log("Full screen request failed");
                });
            }
        }

        function vh(percent) { return (canvas.height * percent) / 100; }

        let gameStarted = false;
        let deathCount = parseInt(localStorage.getItem('deathCount')) || 0;
        let totalClears = parseInt(localStorage.getItem('totalClears')) || 0; 
        let hasCleared = localStorage.getItem('hasCleared') === 'true'; 
        let currentStage = 1;
        let isStageTransition = false;
        let isPausedForEffect = false;
        let fadeAlpha = 0;
        let isEnding = false;
        let isShowingCredit = false; 
        let isHiddenEnding = false; 
        let hiddenScrollY = 0;      
        let isDead = false;
        let deathTimer = 0;
        let particles = [];
        
        let isMouseDown = false;
        let clickDistScale = 1;
        let stage8Check = { top: false, bottom: false };

        const startButton = {
            width: 0, height: 0, x: 0, y: 0, vx: 0, vy: 0, gravity: 0,
            angle: 0, va: 0,
            reset: function() {
                this.width = vh(25);
                this.height = vh(10);
                this.x = canvas.width / 2 - this.width / 2;
                this.y = vh(70);
                this.vx = 0; this.vy = 0; this.angle = 0; this.va = 0;
                let gravityBase = vh(0.05);
                this.gravity = (currentStage === 1) ? gravityBase * 0.25 : gravityBase;
                stage8Check = { top: false, bottom: false };
            },
            draw: function() {
                this.drawSingle(this.x, this.y);
                if (this.x < 0) this.drawSingle(this.x + canvas.width, this.y);
                else if (this.x + this.width > canvas.width) this.drawSingle(this.x - canvas.width, this.y);
            },
            drawSingle: function(px, py) {
                if (isHiddenEnding) return;
                ctx.save();
                ctx.translate(px + this.width / 2, py + this.height / 2);
                ctx.rotate(this.angle);
                if (isMouseDown && !isDead && !isPausedForEffect) {
                    let scaleVal = 1 - (clickDistScale * 0.15);
                    ctx.scale(scaleVal, scaleVal);
                }
                if (isDead && deathTimer > 0) drawCracks(-this.width / 2, -this.height / 2, this.width, this.height);
                if (!isDead && !isEnding && !isShowingCredit) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = 'black'; ctx.lineWidth = vh(0.5);
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = 'black'; ctx.font = `bold ${vh(4)}px 'Courier New'`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('START', 0, 0);
                }
                ctx.restore();
            }
        };

        function drawCracks(x, y, w, h) {
            ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.beginPath();
            for(let i=0; i<12; i++) {
                ctx.moveTo(x + Math.random()*w, y); ctx.lineTo(x + Math.random()*w, y + h);
                ctx.moveTo(x, y + Math.random()*h); ctx.lineTo(x + w, y + Math.random()*h);
            }
            ctx.stroke();
        }

        function createParticles(x, y, w, h) {
            for (let i = 0; i < 60; i++) {
                particles.push({
                    x: x + w / 2, y: y + h / 2,
                    vx: (Math.random() - 0.5) * 40, vy: (Math.random() - 0.5) * 40,
                    size: Math.random() * 15 + 5, life: 1.0
                });
            }
        }

        function triggerDeath() {
            if (isDead) return;
            isDead = true; deathTimer = 10;
            sfxDeath.currentTime = 0; sfxDeath.play();
            createParticles(startButton.x, startButton.y, startButton.width, startButton.height);
            deathCount++;
            localStorage.setItem('deathCount', deathCount);
            setTimeout(() => {
                currentStage = 1; gameStarted = false; isDead = false; particles = []; startButton.reset();
                document.body.style.backgroundImage = "url('space_back1.gif')";
                updateBGM();
            }, 1000);
        }

        function getOverlap(tx, ty) {
            const interX1 = Math.max(startButton.x, tx);
            const interY1 = Math.max(startButton.y, ty);
            const interX2 = Math.min(startButton.x + startButton.width, tx + startButton.width);
            const interY2 = Math.min(startButton.y + startButton.height, ty + startButton.height);
            const interWidth = Math.max(0, interX2 - interX1);
            const interHeight = Math.max(0, interY2 - interY1);
            return (interWidth * interHeight) / (startButton.width * startButton.height);
        }

        function checkStageClear() {
            const threshold = 0.75;
            let tx = canvas.width / 2 - startButton.width / 2;
            let ty = vh(30);
            if (currentStage === 3 || currentStage === 5) { tx = canvas.width * 0.1; ty = vh(10); }
            else if (currentStage === 4 || currentStage === 6) { tx = canvas.width * 0.9 - startButton.width; ty = vh(90) - startButton.height; }
            if (currentStage === 8) {
                const topOverlap = getOverlap(canvas.width * 0.1, vh(10));
                const bottomOverlap = getOverlap(canvas.width * 0.9 - startButton.width, vh(90) - startButton.height);
                if (topOverlap >= threshold) stage8Check.top = true;
                if (bottomOverlap >= threshold) stage8Check.bottom = true;
                if (stage8Check.top && stage8Check.bottom && !isPausedForEffect) proceed();
            } else {
                if (getOverlap(tx, ty) >= threshold && !isPausedForEffect) proceed();
            }
            function proceed() {
                isPausedForEffect = true; 
                setTimeout(() => {
                    if (currentStage === 8) startEnding();
                    else startNextStage();
                }, 500);
            }
        }

        function startNextStage() {
            if (isStageTransition) return;
            isStageTransition = true;
            fadeAlpha = 0;
            const fadeInterval = setInterval(() => {
                if (fadeAlpha < 1) { fadeAlpha += 0.02; } 
                else {
                    clearInterval(fadeInterval);
                    setTimeout(() => {
                        currentStage++;
                        if (currentStage === 7) document.body.style.backgroundImage = "url('space_back4.gif')";
                        else if (currentStage === 8) document.body.style.backgroundImage = "url('space_back3.gif')";
                        updateBGM();
                        gameStarted = false; isPausedForEffect = false;
                        setTimeout(() => { fadeAlpha = 0; isStageTransition = false; startButton.reset(); }, 1000);
                    }, 500);
                }
            }, 16);
        }

        function startEnding() {
            isEnding = true; isStageTransition = true; fadeAlpha = 1; 
            stopAllBGM(); 
            hasCleared = true; localStorage.setItem('hasCleared', 'true');
            totalClears++; localStorage.setItem('totalClears', totalClears); 
            document.body.style.backgroundImage = "url('space_back2.gif')";
            setTimeout(() => {
                bgmMoonlight.play().catch(e => {});
                const fadeIn = setInterval(() => {
                    if (fadeAlpha > 0) fadeAlpha -= 0.005; 
                    else { clearInterval(fadeIn); isStageTransition = false; }
                }, 16);
            }, 3000); 
        }

        function drawObstacles() {
            const activeStages = [2, 5, 6];
            if (activeStages.includes(currentStage) && gameStarted && !isDead) {
                const obsW = vh(2); 
                const obsH = canvas.height * 0.46; 
                const lx = canvas.width * 0.25; 
                const rx = canvas.width * 0.75;
                const y = (canvas.height - obsH) / 2;
                const time = Date.now() / 500; 

                const drawSpiralBox = (bx, by) => {
                    ctx.fillStyle = '#400000';
                    ctx.fillRect(bx, by, obsW, obsH);
                    ctx.strokeStyle = '#FF3030';
                    ctx.lineWidth = vh(0.8); 
                    for (let j = 0; j < 3; j++) {
                        ctx.beginPath();
                        for (let k = 0; k < obsH; k += 5) {
                            const spiralX = bx + (obsW / 2) + Math.sin(k / 30 + time + (j * 2)) * (obsW / 2.5);
                            if (k === 0) ctx.moveTo(spiralX, by + k);
                            else ctx.lineTo(spiralX, by + k);
                        }
                        ctx.stroke();
                    }
                };
                drawSpiralBox(lx, y); drawSpiralBox(rx, y);
                if (startButton.x < lx + obsW && startButton.x + startButton.width > lx && startButton.y < y + obsH && startButton.y + startButton.height > y) triggerDeath();
                if (startButton.x < rx + obsW && startButton.x + startButton.width > rx && startButton.y < y + obsH && startButton.y + startButton.height > y) triggerDeath();
            }
        }

        function drawTargetBox() {
            if (!gameStarted && !isStageTransition && !isEnding && !isShowingCredit || isHiddenEnding) return;
            ctx.setLineDash([10, 10]); ctx.lineWidth = vh(0.3);
            const drawBox = (tx, ty, isCleared) => {
                ctx.strokeStyle = (isCleared || isPausedForEffect) ? 'yellow' : 'white';
                ctx.strokeRect(tx, ty, startButton.width, startButton.height);
            };
            if (currentStage === 8) {
                drawBox(canvas.width * 0.1, vh(10), stage8Check.top);
                drawBox(canvas.width * 0.9 - startButton.width, vh(90) - startButton.height, stage8Check.bottom);
            } else {
                let tx = canvas.width/2 - startButton.width/2; let ty = vh(30);
                if (currentStage === 3 || currentStage === 5) { tx = canvas.width*0.1; ty = vh(10); }
                else if (currentStage === 4 || currentStage === 6) { tx = canvas.width*0.9 - startButton.width; ty = vh(90) - startButton.height; }
                drawBox(tx, ty, false);
            }
            ctx.setLineDash([]);
        }

        function drawHiddenEnding() {
            if (!isHiddenEnding) return;
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.font = `${vh(4)}px 'Courier New'`;
            ctx.fillText(HIDDEN_MESSAGE, canvas.width / 2, canvas.height - hiddenScrollY);
            hiddenScrollY += 1.2;
            if (canvas.height - hiddenScrollY < -vh(10)) {
                ctx.fillStyle = 'gray';
                ctx.font = `${vh(3)}px 'Courier New'`;
                ctx.fillText('Press Any Button to Return', canvas.width / 2, vh(90));
            }
        }

        function drawUI() {
            if (isHiddenEnding) { drawHiddenEnding(); return; }
            if (isEnding && fadeAlpha < 1) {
                ctx.textAlign = 'center';
                ctx.fillStyle = 'yellow'; ctx.font = `bold ${vh(6)}px 'Courier New'`; 
                ctx.fillText('Congratulations! you make it!', canvas.width / 2, vh(25));
                ctx.fillStyle = 'white'; ctx.font = `${vh(5)}px 'Courier New'`;
                ctx.fillText('Press Any Button to Start', canvas.width / 2, vh(50));
                ctx.fillStyle = 'white'; ctx.font = `bold ${vh(12)}px 'Courier New'`; 
                ctx.fillText(`Deaths: ${deathCount}`, canvas.width / 2, vh(70));
                if (deathCount <= 1) {
                    ctx.fillStyle = '#FFD700'; ctx.font = `bold ${vh(12)}px 'Courier New'`;
                    ctx.fillText('UNBELIEVABLE', canvas.width / 2, vh(85));
                }
            } else if (isShowingCredit && fadeAlpha < 1) {
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white'; ctx.font = `bold ${vh(6)}px 'Courier New'`;
                ctx.fillText('ENDING CREDITS', canvas.width / 2, vh(20));
                ctx.font = `${vh(4)}px 'Courier New'`; ctx.fillText('Thanks for playing', canvas.width / 2, vh(28));
                ctx.fillStyle = 'white'; ctx.font = `${vh(5)}px 'Courier New'`;
                ctx.fillText('Press Any Button to Start', canvas.width / 2, vh(50));
                ctx.fillStyle = 'yellow'; ctx.font = `${vh(4)}px 'Courier New'`;
                ctx.fillText('Made By Aview / Completed By You', canvas.width / 2, vh(58));
                if (imgAview.complete) {
                    const imgW = vh(45); const imgH = (imgAview.height / imgAview.width) * imgW;
                    const logoY = vh(95) - imgH;
                    if (totalClears >= 2) { ctx.shadowBlur = 15; ctx.shadowColor = "yellow"; }
                    ctx.drawImage(imgAview, canvas.width / 2 - imgW / 2, logoY, imgW, imgH);
                    ctx.shadowBlur = 0;
                }
            } else if (isStageTransition && fadeAlpha >= 1 && !isEnding) {
                ctx.fillStyle = 'yellow'; ctx.font = `bold ${vh(7)}px 'Courier New'`; ctx.textAlign = 'center';
                ctx.fillText(`STAGE ${currentStage}`, canvas.width / 2, canvas.height / 2);
            } else if (!gameStarted && !isDead && !isEnding && !isShowingCredit) {
                ctx.fillStyle = 'white'; ctx.font = `${vh(5)}px 'Courier New'`; ctx.textAlign = 'center';
                ctx.fillText('Start to Press Any Button', canvas.width / 2, canvas.height / 2);
                if (currentStage !== 1) { ctx.font = `${vh(3)}px 'Courier New'`; ctx.fillText(`- Stage ${currentStage} -`, canvas.width / 2, canvas.height / 2 + vh(7)); }
                if (hasCleared && currentStage === 1) {
                    const bx = canvas.width / 2 - startButton.width / 2; const by = startButton.y + vh(12); 
                    ctx.fillStyle = 'white'; ctx.fillRect(bx, by, startButton.width, startButton.height);
                    ctx.strokeStyle = 'black'; ctx.lineWidth = vh(0.5); ctx.strokeRect(bx, by, startButton.width, startButton.height);
                    ctx.fillStyle = 'black'; ctx.font = `bold ${vh(4)}px 'Courier New'`; ctx.textBaseline = 'middle';
                    ctx.fillText('CREDIT', canvas.width / 2, by + startButton.height / 2); ctx.textBaseline = 'alphabetic';
                }
            }
            if (!isEnding && !isShowingCredit && !isHiddenEnding) {
                ctx.fillStyle = 'white'; ctx.font = `bold ${vh(3)}px 'Courier New'`; ctx.textAlign = 'right';
                ctx.fillText(`Deaths: ${deathCount}`, canvas.width - vh(2), vh(5));
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTargetBox(); drawObstacles();
            if (!isDead && gameStarted && !isStageTransition && !isPausedForEffect && !isEnding && !isShowingCredit && !isHiddenEnding) {
                startButton.vy += startButton.gravity;
                startButton.x += startButton.vx; startButton.y += startButton.vy;
                startButton.angle += startButton.va; startButton.va *= 0.98;
                if (startButton.x + startButton.width < 0) startButton.x += canvas.width;
                else if (startButton.x > canvas.width) startButton.x -= canvas.width;
                if (startButton.y > canvas.height) triggerDeath();
                checkStageClear();
            }
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`; ctx.fillRect(p.x, p.y, p.size, p.size);
                if (p.life <= 0) particles.splice(i, 1);
            });
            if (deathTimer > 0) deathTimer--;
            startButton.draw(); drawUI();
            if (fadeAlpha > 0 && !isHiddenEnding) {
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height);
                if(isEnding || isShowingCredit || isStageTransition) drawUI();
            }
            requestAnimationFrame(gameLoop);
        }

        /**
         * [수정/메모] 통합 입력 처리 핸들러
         * 모바일 터치(touchstart)와 마우스 클릭(mousedown)을 모두 지원
         */
        function handleInput(e) {
            // [신규] 전체화면 전환 시도
            toggleFullScreen();

            if (e.type === 'mousedown' || e.type === 'touchstart') isMouseDown = true;
            if (e.type === 'mouseup' || e.type === 'mouseleave' || e.type === 'touchend') isMouseDown = false;

            if (isHiddenEnding) {
                if (e.type === 'mousedown' || e.type === 'keydown' || e.type === 'touchstart') {
                    isHiddenEnding = false; isShowingCredit = false; currentStage = 1; gameStarted = false;
                    deathCount = 0; localStorage.setItem('deathCount', 0);
                    document.body.style.backgroundImage = "url('space_back1.gif')";
                    stopAllBGM(); updateBGM(); startButton.reset();
                }
                return;
            }

            // 좌표 추출 (터치/마우스 공용)
            let clientX, clientY;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX;
                clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (!gameStarted && !isDead && !isEnding && !isShowingCredit) {
                if (e.type === 'mousedown' || e.type === 'touchstart') {
                    const rect = canvas.getBoundingClientRect();
                    const mx = clientX - rect.left;
                    const my = clientY - rect.top;
                    if (hasCleared && currentStage === 1) {
                        const bx = canvas.width / 2 - startButton.width / 2; const by = startButton.y + vh(12);
                        if (mx > bx && mx < bx + startButton.width && my > by && my < by + startButton.height) {
                            isShowingCredit = true; document.body.style.backgroundImage = "url('space_back2.gif')";
                            updateBGM(); return;
                        }
                    }
                    gameStarted = true; updateBGM();
                } else if (e.type === 'keydown') { gameStarted = true; updateBGM(); }
                return;
            }

            if ((isEnding || isShowingCredit) && !isStageTransition) {
                if (e.type === 'mousedown' || e.type === 'touchstart') {
                    const rect = canvas.getBoundingClientRect();
                    const mx = clientX - rect.left;
                    const my = clientY - rect.top;
                    if (isShowingCredit && totalClears >= 2 && imgAview.complete) {
                        const imgW = vh(45); const imgH = (imgAview.height / imgAview.width) * imgW;
                        const logoX = canvas.width / 2 - imgW / 2; const logoY = vh(95) - imgH;
                        if (mx > logoX && mx < logoX + imgW && my > logoY && my < logoY + imgH) {
                            isHiddenEnding = true; hiddenScrollY = 0; updateBGM(); return;
                        }
                    }
                    isEnding = false; isShowingCredit = false; currentStage = 1; gameStarted = false; 
                    isPausedForEffect = false; fadeAlpha = 0; document.body.style.backgroundImage = "url('space_back1.gif')";
                    stopAllBGM(); updateBGM(); startButton.reset();
                } else if (e.type === 'keydown') {
                    isEnding = false; isShowingCredit = false; currentStage = 1; gameStarted = false; 
                    isPausedForEffect = false; fadeAlpha = 0; document.body.style.backgroundImage = "url('space_back1.gif')";
                    stopAllBGM(); updateBGM(); startButton.reset();
                }
                return;
            }

            if (isStageTransition || isDead || isPausedForEffect) return;

            if (e.type === 'mousedown' || e.type === 'touchstart') {
                const rect = canvas.getBoundingClientRect();
                const mx = clientX - rect.left;
                const my = clientY - rect.top;
                const cx = startButton.x + startButton.width / 2; const cy = startButton.y + startButton.height / 2;
                const dx = mx - cx; const dy = my - cy;
                const cos = Math.cos(-startButton.angle); const sin = Math.sin(-startButton.angle);
                const rotMx = dx * cos - dy * sin; const rotMy = dx * sin + dy * cos;
                if (Math.abs(rotMx) <= startButton.width / 2 && Math.abs(rotMy) <= startButton.height / 2) {
                    const dist = Math.sqrt(dx*dx + dy*dy); const maxDist = Math.sqrt(Math.pow(startButton.width/2, 2) + Math.pow(startButton.height/2, 2));
                    clickDistScale = Math.min(dist / maxDist, 1);
                    sfxBounce.currentTime = 0; sfxBounce.volume = 0.1 + (clickDistScale * (MAX_BOUNCE_VOL - 0.1)); sfxBounce.play();
                    let mult = (currentStage === 1) ? 0.05 : 0.2; let bounceBase = (currentStage === 1) ? vh(0.3) : vh(1.2);
                    startButton.vx = (cx - mx) * mult; startButton.vy = (cy - my) * mult - bounceBase;
                    if (currentStage >= 7) startButton.va += (dx / startButton.width) * 0.15;
                }
            }
        }

        // [신규] 터치 이벤트 리스너 추가 (반응성 향상)
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e); }, { passive: false });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleInput(e); }, { passive: false });
        
        canvas.addEventListener('mousedown', handleInput);
        window.addEventListener('mouseup', handleInput);
        document.addEventListener('keydown', handleInput);
        
        window.addEventListener('resize', () => { 
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
            startButton.reset(); 
        });

        canvas.width = window.innerWidth; 
        canvas.height = window.innerHeight;
        startButton.reset(); 
        gameLoop();
    </script>
</body>
</html>